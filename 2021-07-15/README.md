# 연습문제 동전교환

## 문제 이해

- 입력값 k는 만들어야하는 원.
- arr는 코인 배열이 들어온다.
- k를 만들 수 있는 코인의 최소 개수를 리턴.

## 계획

- dfs를 돌 때, depth = 깊이 즉, 동전의 개수와 누적된 값 + 그 다음 코인의 값을 더해서 돈다.
- 재귀의 base case는 누적 값(sum)이 k보다 크고, 깊이가 기존 값(answer)와 같다면 종료한다.
- 만약 누적 값(sum)과 k원이 같다면 기존 값(answer)과 depth중 더 적은 수를 기존 값에 재할당하는 방식으로 최소 개수를 찾는다.
- 그렇지 않다면 코인 배열의 길이만큼 for문을 돌면서 dfs 호출을 한다.

## 느낀점

- 이전과 다른 방식으로 dfs를 이용해 문제를 풀어보았다.
- 함수 안에서 for문으로 코인배열을 가장 큰 코인 순으로 순회하고, 원하는 값(k)를 도달할 때까지 k로 코인을 나누고, 다시 k를 모듈러 하는 방식으로 풀었었다.
- 해당 풀이는 작은 코인의 경우부터 순회하기 때문에 이전에 풀었던 풀이보단 효율적이지 않을거라고 판단된다.
- 반면에 이전에 풀었던 큰 코인 순으로 순회하는 방식을 이용하면 최소개수의 코인을 구하는데 더 효율적일 것이다.
